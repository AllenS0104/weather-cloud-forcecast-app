<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>å¤©æ°”åœ°å›¾ + äº‘æµ·åˆ†æ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: "Segoe UI", sans-serif; margin: 0; padding: 0; background-size: cover; background-position: center; transition: background 1s ease-in-out; color: #222; }
  #container { background: rgba(255, 255, 255, 0.9); padding: 20px; max-width: 960px; margin: 20px auto; border-radius: 12px; box-shadow: 0 0 10px rgba(0,0,0,0.2); }
  h1 { text-align: center; }
  #map { height: 300px; border-radius: 10px; }
  
  #search-box { 
    margin: 10px 0; 
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
  }
  
  #search-box input, #search-box select, #search-box button { 
    padding: 8px 12px; 
    font-size: 16px; 
    border: 1px solid #ccc;
    border-radius: 5px;
  }
  #search-box input { flex-grow: 1; max-width: 300px; }

  #search-box button {
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border-color: #007bff;
    transition: background-color 0.2s;
  }
  #search-box button:hover {
    background-color: #0056b3;
  }
  #locate-btn {
      background-color: #28a745;
      border-color: #28a745;
  }
  #locate-btn:hover {
      background-color: #218838;
  }
  
  #weather p { line-height: 1.6; }
  .label { font-weight: bold; }
  .error-message { color: red; font-weight: bold; }
  canvas { max-width: 100%; margin-top: 30px; }
  #rainChart { max-height: 150px; }
</style>
</head>
<body>
<div id="container">
  <h1>ğŸŒ¤ï¸ å¤©æ°”åœ°å›¾ + äº‘æµ·é¢„æµ‹</h1>
  <div id="search-box">
    <input type="text" id="address" placeholder="è¯·è¾“å…¥åœ°ç‚¹ (é»˜è®¤: åŒ—äº¬)" onkeydown="if(event.key==='Enter') searchAddress()">
    <button onclick="searchAddress()">ç¡®è®¤</button>
    <button id="locate-btn" onclick="locateAndFetch()">å½“å‰ä½ç½®</button>
    <select id="daySelector" onchange="dayChanged()"></select>
  </div>
  <div id="map"></div>
  <div id="weather">åŠ è½½ä¸­...</div>
  <canvas id="cloudChart"></canvas>
  <canvas id="rainChart"></canvas>
</div>
<script>
// é»˜è®¤åæ ‡ï¼ˆåŒ—äº¬ï¼‰
let lat = 39.9042, lon = 116.4074;
let map, marker, cloudChart, rainChart;
let selectedDayIndex = 0;
let elevation = 300;
let lastWeatherData = null;

const API_ENDPOINTS = [
    'https://api.open-meteo.com',
    'https://ensemble-api.open-meteo.com'
];

async function getRealElevation(lat, lon) {
  try {
    const res = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`);
    if (!res.ok) throw new Error(`æµ·æ‹”APIé”™è¯¯: ${res.status} ${res.statusText}`);
    const data = await res.json();
    if (data.results && data.results.length > 0) return data.results[0].elevation;
    throw new Error("æµ·æ‹”APIæœªè¿”å›æœ‰æ•ˆç»“æœ");
  } catch (e) {
    console.error("æµ·æ‹”è·å–å¤±è´¥:", e);
    document.getElementById("weather").innerHTML = `<p class="error-message">è·å–æµ·æ‹”å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼ã€‚é”™è¯¯: ${e.message}</p>`;
    return 300;
  }
}

function windDirection(deg) {
  const dirs = ['åŒ—', 'ä¸œåŒ—', 'ä¸œ', 'ä¸œå—', 'å—', 'è¥¿å—', 'è¥¿', 'è¥¿åŒ—'];
  return dirs[Math.round(deg / 45) % 8] + 'é£';
}

function setBackgroundByTimeFromWeather(timeStr) {
  const hour = new Date(timeStr).getHours();
  const dayImg = "https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1950&q=80";
  const nightImg = "https://images.unsplash.com/photo-1503264116251-35a269479413?auto=format&fit=crop&w=1950&q=80";
  document.body.style.backgroundImage = `url(${hour >= 6 && hour < 18 ? dayImg : nightImg})`;
}

function initMap() {
  map = L.map('map').setView([lat, lon], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);
  marker = L.marker([lat, lon]).addTo(map);
  map.on('click', e => {
    lat = e.latlng.lat;
    lon = e.latlng.lng;
    marker.setLatLng(e.latlng);
    fetchWeatherAndElevation();
  });
}

async function searchAddress() {
  const addr = document.getElementById("address").value.trim();
  if (!addr) return;
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(addr)}&format=json&accept-language=zh-CN`);
    if (!res.ok) throw new Error(`åœ°å€æŸ¥è¯¢æœåŠ¡é”™è¯¯: ${res.status}`);
    const data = await res.json();
    if (data.length > 0) {
      lat = parseFloat(data[0].lat);
      lon = parseFloat(data[0].lon);
      map.setView([lat, lon], 9);
      marker.setLatLng([lat, lon]);
      fetchWeatherAndElevation();
    } else {
      alert("æœªæ‰¾åˆ°è¯¥åœ°å€ï¼Œè¯·å°è¯•å…¶ä»–å…³é”®è¯ã€‚");
    }
  } catch (e) {
    alert(`åœ°å€æŸ¥è¯¢å¤±è´¥: ${e.message}`);
  }
}

function populateDateSelector(hourlyTime) {
    const selector = document.getElementById("daySelector");
    const firstDay = hourlyTime[0].split('T')[0];
    if (selector.options.length > 0 && selector.options[0].dataset.day === firstDay) {
        selector.value = selectedDayIndex;
        return;
    }
    selector.innerHTML = "";
    const uniqueDays = [...new Set(hourlyTime.map(t => t.split('T')[0]))];
    uniqueDays.slice(0, 7).forEach((day, index) => {
        const opt = document.createElement("option");
        opt.value = index;
        opt.dataset.day = day;
        opt.textContent = new Date(day).toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'short' });
        if (index === 0) opt.textContent += " (ä»Šå¤©)";
        selector.appendChild(opt);
    });
    selector.value = selectedDayIndex;
}

function dayChanged() {
    selectedDayIndex = parseInt(document.getElementById("daySelector")?.value || 0);
    if(lastWeatherData) {
        updateDisplay(lastWeatherData);
    }
}

async function fetchWeatherAndElevation() {
    document.getElementById("weather").innerHTML = "æ­£åœ¨è·å–æµ·æ‹”æ•°æ®...";
    elevation = await getRealElevation(lat, lon);
    fetchWeatherWithFailover();
}

function fetchWeatherWithFailover(apiIndex = 0) {
    if (apiIndex >= API_ENDPOINTS.length) {
        document.getElementById("weather").innerHTML = `<p class="error-message">æ‰€æœ‰å¤©æ°”æ•°æ®æºå‡è¯·æ±‚å¤±è´¥ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åå†è¯•ã€‚</p>`;
        return;
    }
    const baseApiUrl = API_ENDPOINTS[apiIndex];
    document.getElementById("weather").innerHTML = `æ­£åœ¨ä»æ•°æ®æº ${apiIndex + 1} åŠ è½½å¤©æ°”æ•°æ®...`;
    
    const params = new URLSearchParams({
        latitude: lat,
        longitude: lon,
        current: 'temperature_2m,relative_humidity_2m,cloudcover,visibility,wind_speed_10m,wind_direction_10m',
        hourly: 'temperature_2m,relative_humidity_2m,cloudcover,cloudcover_low,precipitation,visibility,wind_speed_10m,wind_direction_10m,precipitation_probability',
        daily: 'sunrise,sunset',
        timezone: 'Asia/Shanghai'
    });
    const url = `${baseApiUrl}/v1/forecast?${params.toString()}`;

    fetch(url)
    .then(res => {
      if (!res.ok) throw new Error(`å¤©æ°”APIè¯·æ±‚å¤±è´¥: ${res.status} ${res.statusText}`);
      return res.json();
    })
    .then(data => {
      if (!data || !data.hourly || !data.hourly.time) throw new Error("å¤©æ°”APIè¿”å›çš„æ•°æ®æ ¼å¼ä¸å®Œæ•´æˆ–æ— æ•ˆã€‚");
      lastWeatherData = data;
      populateDateSelector(data.hourly.time);
      updateDisplay(data);
    })
    .catch(error => {
      console.error(`æ•°æ®æº ${apiIndex + 1} (${baseApiUrl}) è¯·æ±‚å¤±è´¥:`, error);
      fetchWeatherWithFailover(apiIndex + 1);
    });
}

function updateDisplay(data) {
    const hourly = data.hourly;
    const daily = data.daily;
    const start = selectedDayIndex * 24;

    const displayIndexForBg = start;
    if (displayIndexForBg >= hourly.time.length) return;
    setBackgroundByTimeFromWeather(hourly.time[displayIndexForBg]);
    
    let weatherHtml = `<p><span class="label">ğŸ“ åæ ‡ï¼š</span>${lat.toFixed(4)}, ${lon.toFixed(4)} (æµ·æ‹”: ${elevation}ç±³)</p>`;
    
    if (selectedDayIndex === 0 && data.current) {
        const current = data.current;
        const temp = current.temperature_2m;
        const humidity = current.relative_humidity_2m;
        const cloudcover = current.cloudcover;
        const windSpeed = current.wind_speed_10m;
        const windDir = current.wind_direction_10m;
        const visibility = current.visibility / 1000;
        const td = temp - ((100 - humidity) / 5);
        const cloudBase = Math.round((temp - td) * 125);
        const suggestion = (cloudBase < elevation && humidity > 85 && visibility > 8) ? "ğŸŒ«ï¸ äº‘åº•ä½äºåœ°å½¢ï¼Œæœ‰å¾ˆå¤§æ¦‚ç‡å‡ºç°äº‘æµ·ï¼" : "ğŸŒ¥ï¸ äº‘æµ·å‡ºç°å¯èƒ½æ€§ä¸å¤§";
        weatherHtml += `<p><span class="label">ğŸŒ¡ï¸ å½“å‰æ¸©åº¦ï¼š</span>${temp.toFixed(1)}Â°C</p><p><span class="label">ğŸ’§ å½“å‰æ¹¿åº¦ï¼š</span>${humidity.toFixed(0)}%</p><p><span class="label">â˜ï¸ å½“å‰äº‘é‡ï¼š</span>${cloudcover.toFixed(0)}%</p><p><span class="label">ğŸŒ¬ï¸ å½“å‰é£é€Ÿï¼š</span>${windSpeed.toFixed(1)} m/sï¼Œ${windDirection(windDir)}</p><p><span class="label">ğŸ‘ï¸ å½“å‰èƒ½è§åº¦ï¼š</span>${visibility.toFixed(1)} å…¬é‡Œ</p><p><span class="label">ğŸŒ«ï¸ äº‘åº•é«˜åº¦ (åŸºäºå½“å‰)ï¼š</span>${cloudBase.toFixed(0)} ç±³</p><p><span class="label">â›°ï¸ äº‘æµ·é¢„æµ‹ (åŸºäºå½“å‰)ï¼š</span>${suggestion}</p>`;
    } else {
        const dayTemps = hourly.temperature_2m.slice(start, start + 24);
        const dayHums = hourly.relative_humidity_2m.slice(start, start + 24);
        const dayClouds = hourly.cloudcover.slice(start, start + 24);
        const dayWinds = hourly.wind_speed_10m.slice(start, start + 24);
        const dayVis = hourly.visibility.slice(start, start + 24);
        const dayBases = dayTemps.map((t, i) => { const h = dayHums[i]; const td = t - ((100 - h) / 5); return Math.round((t - td) * 125); });
        const minTemp = Math.min(...dayTemps);
        const maxTemp = Math.max(...dayTemps);
        const minHum = Math.min(...dayHums);
        const maxHum = Math.max(...dayHums);
        const minCloud = Math.min(...dayClouds);
        const maxCloud = Math.max(...dayClouds);
        const minWind = Math.min(...dayWinds);
        const maxWind = Math.max(...dayWinds);
        const minVis = Math.min(...dayVis) / 1000;
        const maxVis = Math.max(...dayVis) / 1000;
        const minBase = Math.min(...dayBases);
        const maxBase = Math.max(...dayBases);
        const suggestion = (minBase < elevation && maxHum > 85 && maxVis > 8) ? "ğŸŒ«ï¸ äº‘åº•ä½äºåœ°å½¢ï¼Œæœ‰å¾ˆå¤§æ¦‚ç‡å‡ºç°äº‘æµ·ï¼" : "ğŸŒ¥ï¸ äº‘æµ·å‡ºç°å¯èƒ½æ€§ä¸å¤§";
        weatherHtml += `<p><span class="label">ğŸŒ¡ï¸ æ¸©åº¦èŒƒå›´ (å…¨å¤©)ï¼š</span>${minTemp.toFixed(1)}Â°C ~ ${maxTemp.toFixed(1)}Â°C</p><p><span class="label">ğŸ’§ æ¹¿åº¦èŒƒå›´ (å…¨å¤©)ï¼š</span>${minHum.toFixed(0)}% ~ ${maxHum.toFixed(0)}%</p><p><span class="label">â˜ï¸ äº‘é‡èŒƒå›´ (å…¨å¤©)ï¼š</span>${minCloud.toFixed(0)}% ~ ${maxCloud.toFixed(0)}%</p><p><span class="label">ğŸŒ¬ï¸ é£é€ŸèŒƒå›´ (å…¨å¤©)ï¼š</span>${minWind.toFixed(1)} m/s ~ ${maxWind.toFixed(1)} m/s</p><p><span class="label">ğŸ‘ï¸ èƒ½è§åº¦èŒƒå›´ (å…¨å¤©)ï¼š</span>${minVis.toFixed(1)} km ~ ${maxVis.toFixed(1)} km</p><p><span class="label">ğŸŒ«ï¸ äº‘åº•é«˜åº¦èŒƒå›´ (å…¨å¤©)ï¼š</span>${minBase.toFixed(0)} m ~ ${maxBase.toFixed(0)} m</p><p><span class="label">â›°ï¸ äº‘æµ·é¢„æµ‹ (åŸºäºå…¨å¤©)ï¼š</span>${suggestion}</p>`;
    }
    
    const dayPrecipProbs = hourly.precipitation_probability.slice(start, start + 24);
    const maxPrecipProb = Math.max(...dayPrecipProbs);
    const sunrise = daily.sunrise[selectedDayIndex]?.slice(11) || 'N/A';
    const sunset = daily.sunset[selectedDayIndex]?.slice(11) || 'N/A';
    
    weatherHtml += `<p><span class="label">ğŸŒ§ï¸ é™æ°´æ¦‚ç‡ï¼š</span>${maxPrecipProb}% (å…¨å¤©æœ€é«˜)</p><p><span class="label">ğŸŒ… æ—¥å‡ºï¼š</span>${sunrise}ï¼ŒğŸŒ‡ æ—¥è½ï¼š${sunset}</p>`;

    document.getElementById("weather").innerHTML = weatherHtml;

    const hours = hourly.time.slice(start, start + 24).map(t => new Date(t).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false }));
    const cloud = hourly.cloudcover.slice(start, start + 24);
    const rain = hourly.precipitation.slice(start, start + 24);
    const lowCloud = hourly.cloudcover_low.slice(start, start + 24);
    const temps = hourly.temperature_2m.slice(start, start + 24);
    const hums = hourly.relative_humidity_2m.slice(start, start + 24);
    const bases = temps.map((t, i) => { const currentHum = hums[i] || 0; const currentTempTd = t - ((100 - currentHum) / 5); return Math.round((t - currentTempTd) * 125); });

    if (cloudChart) cloudChart.destroy();
    cloudChart = new Chart(document.getElementById("cloudChart"), { type: 'line', data: { labels: hours, datasets: [ { label: "â˜ï¸ äº‘é‡ (%)", data: cloud, borderColor: "#4682B4", backgroundColor: "rgba(70,130,180,0.2)", yAxisID: 'y1', fill: true }, { label: "ğŸŒ«ï¸ äº‘åº•é«˜åº¦ (m)", data: bases, borderColor: "#FF6384", backgroundColor: "rgba(255,99,132,0.2)", yAxisID: 'y2', fill: false }, { label: "ğŸŒ¥ï¸ ä½äº‘è¦†ç›–ç‡ (%)", data: lowCloud, borderColor: "#9ACD32", backgroundColor: "rgba(154,205,50,0.2)", yAxisID: 'y1', fill: false }] }, options: { responsive: true, scales: { y1: { position: 'left', beginAtZero: true, max: 100, title: { display: true, text: 'äº‘é‡ (%)' } }, y2: { position: 'right', beginAtZero: true, title: { display: true, text: 'äº‘åº•é«˜åº¦ (m)' }, grid: { drawOnChartArea: false } }, }, interaction: { mode: 'index', intersect: false }, plugins: { tooltip: { mode: 'index', intersect: false } } } });
    if (rainChart) rainChart.destroy();
    rainChart = new Chart(document.getElementById("rainChart"), { type: 'bar', data: { labels: hours, datasets: [{ label: 'ğŸŒ§ï¸ é™é›¨ (mm)', data: rain, backgroundColor: 'rgba(0, 180, 150, 0.6)' }] }, options: { responsive: true, scales: { y: { beginAtZero: true } } } });
}

function locateAndFetch() {
    document.getElementById("weather").innerHTML = "æ­£åœ¨è·å–æ‚¨çš„å½“å‰ä½ç½®...";
    navigator.geolocation.getCurrentPosition(pos => {
      lat = pos.coords.latitude;
      lon = pos.coords.longitude;
      map.setView([lat, lon], 9);
      marker.setLatLng([lat, lon]);
      fetchWeatherAndElevation();
    }, () => {
        alert("å®šä½å¤±è´¥ï¼æµè§ˆå™¨å¯èƒ½æ²¡æœ‰æƒé™æˆ–æ— æ³•è·å–ä½ç½®ã€‚");
        console.log("å®šä½å¤±è´¥");
    });
}

// --- åˆå§‹åŠ è½½ ---
initMap();
// ä¿®å¤ç‚¹ï¼šä¸å†è‡ªåŠ¨è°ƒç”¨ locateAndFetch()ï¼Œé¿å…å¯åŠ¨æ—¶å°±å¼¹çª—
// locateAndFetch(); 
// ç›´æ¥åŠ è½½é»˜è®¤åœ°ç‚¹çš„å¤©æ°”
fetchWeatherAndElevation();

</script>
</body>
</html>```